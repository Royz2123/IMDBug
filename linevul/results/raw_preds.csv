Unnamed: 0,index,processed_func,target,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul_func_with_fix,flaw_line,flaw_line_index,raw_preds
,buffer overflow 1,"int main(void)
{
    char buff[15];
    int pass = 0;

    // Needs fixing, very bad
    printf(""\n Enter the password : \n"");
    gets(buff);

    if(strcmp(buff, ""thegeekstuff""))
    {
        printf (""\n Wrong Password \n"");
    }
    else
    {
        printf (""\n Correct Password \n"");
        pass = 1;
    }

    if(pass)
    {
       /* Now Give root or admin rights to user*/
        printf (""\n Root privileges given to the user \n"");
    }

    return 0;
}",1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,True
99.0,183429,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
xmlNodePtr cur)
{
if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
if (cur == NULL) {
cur = ctxt->context->node;
if (cur == NULL)
return (NULL);
ctxt->ancestor = cur->parent;
}
if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
cur = cur->prev;
while (cur->prev == NULL) {
cur = cur->parent;
if (cur == NULL)
return (NULL);
if (cur == ctxt->context->doc->children)
return (NULL);
if (cur != ctxt->ancestor)
return (cur);
ctxt->ancestor = cur->parent;
}
cur = cur->prev;
while (cur->last != NULL)
cur = cur->last;
return (cur);
}
",1,,,,,,,,,,,,,,,2010-11,,2.0,https://github.com/chromium/chromium/commit/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58,a44b00c88bc5ea35b5b150217c5fd6e4ce168e58,"Apply behaviour change fix from upstream for previous XPath change.

BUG=58731
TEST=NONE

Review URL: http://codereview.chromium.org/4027006

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@63572 0039d316-1c4b-4281-b951-d872f2087c98",3.0,third_party/libxml/src/xpath.c,"{""sha"": ""832678a8b6360e45389c42744108c046cf695be1"", ""filename"": ""third_party/libxml/README.chromium"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/README.chromium"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/README.chromium"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libxml/README.chromium?ref=a44b00c88bc5ea35b5b150217c5fd6e4ce168e58"", ""patch"": ""@@ -10,6 +10,7 @@ Current version: 2.7.7.\n \n Modifications:\n - Import XPath fix http://git.gnome.org/browse/libxml2/commit/?id=91d19754d46acd4a639a8b9e31f50f31c78f8c9c\n+- Import follow-on for above commit: http://git.gnome.org/browse/libxml2/commit/?id=ea90b894146030c214a7df6d8375310174f134b9\n \n To import a new snapshot of libxml:\n ""}<_**next**_>{""sha"": ""5d3474ef4d949d0d6ceb1c646e2ef312cdcc9ed3"", ""filename"": ""third_party/libxml/src/xpath.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 16, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/src/xpath.c"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a44b00c88bc5ea35b5b150217c5fd6e4ce168e58/third_party/libxml/src/xpath.c"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/libxml/src/xpath.c?ref=a44b00c88bc5ea35b5b150217c5fd6e4ce168e58"", ""patch"": ""@@ -8106,17 +8106,17 @@ xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n xmlNodePtr\n xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n-\treturn(NULL);\n-    if (cur != NULL) {\n-        if ((cur->type == XML_ATTRIBUTE_NODE) ||\n-            (cur->type == XML_NAMESPACE_DECL))\n+    if ((cur != NULL) && (cur->type  != XML_ATTRIBUTE_NODE) &&\n+        (cur->type != XML_NAMESPACE_DECL) && (cur->children != NULL))\n+        return(cur->children);\n+\n+    if (cur == NULL) {\n+        cur = ctxt->context->node;\n+        if (cur->type == XML_NAMESPACE_DECL)\n             return(NULL);\n-        if (cur->children != NULL)\n-            return cur->children ;\n+        if (cur->type == XML_ATTRIBUTE_NODE)\n+            cur = cur->parent;\n     }\n-    if (cur == NULL) cur = ctxt->context->node;\n     if (cur == NULL) return(NULL) ; /* ERROR */\n     if (cur->next != NULL) return(cur->next) ;\n     do {\n@@ -8170,11 +8170,13 @@ xmlNodePtr\n xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n-\treturn(NULL);\n-    if (cur == NULL)\n+    if (cur == NULL) {\n         cur = ctxt->context->node;\n+        if (cur->type == XML_NAMESPACE_DECL)\n+            return(NULL);\n+        if (cur->type == XML_ATTRIBUTE_NODE)\n+            return(cur->parent);\n+    }\n     if (cur == NULL)\n \treturn (NULL);\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n@@ -8214,13 +8216,12 @@ xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                               xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n-\treturn(NULL);\n     if (cur == NULL) {\n         cur = ctxt->context->node;\n         if (cur == NULL)\n             return (NULL);\n+        if (cur->type == XML_NAMESPACE_DECL)\n+            return (NULL);\n         ctxt->ancestor = cur->parent;\n     }\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))""}","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
        if (cur->type == XML_NAMESPACE_DECL)
            return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
",C,"        if (cur->type == XML_NAMESPACE_DECL)
            return (NULL);
","    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
",,"@@ -8106,17 +8106,17 @@ xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 xmlNodePtr
 xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
-	(ctxt->context->node->type == XML_NAMESPACE_DECL))
-	return(NULL);
-    if (cur != NULL) {
-        if ((cur->type == XML_ATTRIBUTE_NODE) ||
-            (cur->type == XML_NAMESPACE_DECL))
+    if ((cur != NULL) && (cur->type  != XML_ATTRIBUTE_NODE) &&
+        (cur->type != XML_NAMESPACE_DECL) && (cur->children != NULL))
+        return(cur->children);
+
+    if (cur == NULL) {
+        cur = ctxt->context->node;
+        if (cur->type == XML_NAMESPACE_DECL)
             return(NULL);
-        if (cur->children != NULL)
-            return cur->children ;
+        if (cur->type == XML_ATTRIBUTE_NODE)
+            cur = cur->parent;
     }
-    if (cur == NULL) cur = ctxt->context->node;
     if (cur == NULL) return(NULL) ; /* ERROR */
     if (cur->next != NULL) return(cur->next) ;
     do {
@@ -8170,11 +8170,13 @@ xmlNodePtr
 xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
-	(ctxt->context->node->type == XML_NAMESPACE_DECL))
-	return(NULL);
-    if (cur == NULL)
+    if (cur == NULL) {
         cur = ctxt->context->node;
+        if (cur->type == XML_NAMESPACE_DECL)
+            return(NULL);
+        if (cur->type == XML_ATTRIBUTE_NODE)
+            return(cur->parent);
+    }
     if (cur == NULL)
 	return (NULL);
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
@@ -8214,13 +8216,12 @@ xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
-	(ctxt->context->node->type == XML_NAMESPACE_DECL))
-	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
+        if (cur->type == XML_NAMESPACE_DECL)
+            return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))",Chrome,a44b00c88bc5ea35b5b150217c5fd6e4ce168e58,eef2c2ed6ea089b49c0f6468154d5a4d524abaeb,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
//flaw_line_below:
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
//flaw_line_below:
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
//flaw_line_below:
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
//fix_flaw_line_below:
//        if (cur->type == XML_NAMESPACE_DECL)
//fix_flaw_line_below:
//            return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
",    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||/~/	(ctxt->context->node->type == XML_NAMESPACE_DECL))/~/	return(NULL);,"4,5,6",True
66.0,178042,"static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
{
{
size_t len;
const char *p;
char c;
int ret = 1;

for (p = key; (c = *p); p++) {
/* valid characters are a..z,A..Z,0..9 */
if (!((c >= 'a' && c <= 'z')
|| (c >= 'A' && c <= 'Z')
|| (c >= '0' && c <= '9')
|| c == ','
|| c == '-')) {
ret = 0;
break;
}
}

len = p - key;

/* Somewhat arbitrary length limit here, but should be way more than
anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
if (len == 0 || len > 128) {
ret = 0;
}

return ret;
}

static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
{
size_t key_len;
const char *p;
int i;
int n;

key_len = strlen(key);
if (key_len <= data->dirdepth ||
buflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {
return NULL;
}

p = key;
memcpy(buf, data->basedir, data->basedir_len);
n = data->basedir_len;
buf[n++] = PHP_DIR_SEPARATOR;
for (i = 0; i < (int)data->dirdepth; i++) {
buf[n++] = *p++;
buf[n++] = PHP_DIR_SEPARATOR;
}
memcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);
n += sizeof(FILE_PREFIX) - 1;
memcpy(buf + n, key, key_len);
n += key_len;

ps_files_close(data);

               if (!ps_files_valid_key(key)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
                       PS(invalid_session_id) = 1;
return;
}
if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
return;
}
if (data->fd != -1) {
#ifdef PHP_WIN32
/* On Win32 locked files that are closed without being explicitly unlocked
will be unlocked only when ""system resources become available"". */
flock(data->fd, LOCK_UN);
#endif
close(data->fd);
data->fd = -1;
}
}

static void ps_files_open(ps_files *data, const char *key TSRMLS_DC)
{
char buf[MAXPATHLEN];

if (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {
if (data->lastkey) {
efree(data->lastkey);
data->lastkey = NULL;
}

ps_files_close(data);

if (!ps_files_valid_key(key)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
PS(invalid_session_id) = 1;
return;
}
if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
return;
}

data->lastkey = estrdup(key);

data->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);

if (data->fd != -1) {
#ifndef PHP_WIN32
/* check to make sure that the opened file is not a symlink, linking to data outside of allowable dirs */
if (PG(open_basedir)) {
struct stat sbuf;

if (fstat(data->fd, &sbuf)) {
close(data->fd);
return;
}
if (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {
close(data->fd);
return;
}
}
#endif
flock(data->fd, LOCK_EX);

#ifdef F_SETFD
# ifndef FD_CLOEXEC
#  define FD_CLOEXEC 1
# endif
if (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)"", data->fd, strerror(errno), errno);
}
#endif
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""open(%s, O_RDWR) failed: %s (%d)"", buf, strerror(errno), errno);
}
}
}

static int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)
{
DIR *dir;
char dentry[sizeof(struct dirent) + MAXPATHLEN];
struct dirent *entry = (struct dirent *) &dentry;
struct stat sbuf;
char buf[MAXPATHLEN];
time_t now;
int nrdels = 0;
size_t dirname_len;

dir = opendir(dirname);
if (!dir) {
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ps_files_cleanup_dir: opendir(%s) failed: %s (%d)"", dirname, strerror(errno), errno);
return (0);
}

time(&now);

return (nrdels);
}

#define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()

PS_OPEN_FUNC(files)
(now - sbuf.st_mtime) > maxlifetime) {
VCWD_UNLINK(buf);
nrdels++;
}
}
",1,None,Remote,Not required,Partial,CVE-2011-4718,https://www.cvedetails.com/cve/CVE-2011-4718/,CWE-264,Medium,Partial,Partial,,13/08/2013,6.8,Session fixation vulnerability in the Sessions subsystem in PHP before 5.5.2 allows remote attackers to hijack web sessions by specifying a session ID.,13/08/2013,,17.0,https://git.php.net/?p=php-src.git;a=commit;h=25e8fcc88fa20dc9d4c47184471003f436927cde,25e8fcc88fa20dc9d4c47184471003f436927cde,,2.0,,," static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
 {
{
	size_t len;
	const char *p;
	char c;
	int ret = 1;

	for (p = key; (c = *p); p++) {
		/* valid characters are a..z,A..Z,0..9 */
		if (!((c >= 'a' && c <= 'z')
				|| (c >= 'A' && c <= 'Z')
				|| (c >= '0' && c <= '9')
				|| c == ','
				|| c == '-')) {
			ret = 0;
			break;
		}
	}

	len = p - key;

	/* Somewhat arbitrary length limit here, but should be way more than
	   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
	if (len == 0 || len > 128) {
		ret = 0;
	}

	return ret;
}

static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
{
	size_t key_len;
	const char *p;
	int i;
	int n;

	key_len = strlen(key);
	if (key_len <= data->dirdepth ||
		buflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {
		return NULL;
	}

	p = key;
	memcpy(buf, data->basedir, data->basedir_len);
	n = data->basedir_len;
	buf[n++] = PHP_DIR_SEPARATOR;
	for (i = 0; i < (int)data->dirdepth; i++) {
		buf[n++] = *p++;
		buf[n++] = PHP_DIR_SEPARATOR;
	}
	memcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);
	n += sizeof(FILE_PREFIX) - 1;
	memcpy(buf + n, key, key_len);
	n += key_len;
 
                ps_files_close(data);
 
               if (php_session_valid_key(key) == FAILURE) {
                        php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
                        return;
                }

                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
                        return;
                }
	if (data->fd != -1) {
#ifdef PHP_WIN32
		/* On Win32 locked files that are closed without being explicitly unlocked
		   will be unlocked only when ""system resources become available"". */
		flock(data->fd, LOCK_UN);
#endif
		close(data->fd);
		data->fd = -1;
	}
}

static void ps_files_open(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];

	if (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {
		if (data->lastkey) {
			efree(data->lastkey);
			data->lastkey = NULL;
		}

		ps_files_close(data);

		if (!ps_files_valid_key(key)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
			PS(invalid_session_id) = 1;
			return;
		}
		if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
			return;
		}

		data->lastkey = estrdup(key);

		data->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);

		if (data->fd != -1) {
#ifndef PHP_WIN32
			/* check to make sure that the opened file is not a symlink, linking to data outside of allowable dirs */
			if (PG(open_basedir)) {
				struct stat sbuf;

				if (fstat(data->fd, &sbuf)) {
					close(data->fd);
					return;
				}
				if (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {
					close(data->fd);
					return;
				}
			}
#endif
			flock(data->fd, LOCK_EX);

#ifdef F_SETFD
# ifndef FD_CLOEXEC
#  define FD_CLOEXEC 1
# endif
			if (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)"", data->fd, strerror(errno), errno);
			}
#endif
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""open(%s, O_RDWR) failed: %s (%d)"", buf, strerror(errno), errno);
		}
	}
}

static int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)
{
	DIR *dir;
	char dentry[sizeof(struct dirent) + MAXPATHLEN];
	struct dirent *entry = (struct dirent *) &dentry;
	struct stat sbuf;
	char buf[MAXPATHLEN];
	time_t now;
	int nrdels = 0;
	size_t dirname_len;

	dir = opendir(dirname);
	if (!dir) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ps_files_cleanup_dir: opendir(%s) failed: %s (%d)"", dirname, strerror(errno), errno);
		return (0);
	}

	time(&now);

        return (nrdels);
 }
 
static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
       char buf[MAXPATHLEN];
       struct stat sbuf;

       if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
               return FAILURE;
       }
       if (VCWD_STAT(buf, &sbuf)) {
               return FAILURE;
       }
       return SUCCESS;
}


 #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()
 
 PS_OPEN_FUNC(files)
						(now - sbuf.st_mtime) > maxlifetime) {
					VCWD_UNLINK(buf);
					nrdels++;
				}
			}
"," static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
 {
{
	size_t len;
	const char *p;
	char c;
	int ret = 1;

	for (p = key; (c = *p); p++) {
		/* valid characters are a..z,A..Z,0..9 */
		if (!((c >= 'a' && c <= 'z')
				|| (c >= 'A' && c <= 'Z')
				|| (c >= '0' && c <= '9')
				|| c == ','
				|| c == '-')) {
			ret = 0;
			break;
		}
	}

	len = p - key;

	/* Somewhat arbitrary length limit here, but should be way more than
	   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
	if (len == 0 || len > 128) {
		ret = 0;
	}

	return ret;
}

static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
{
	size_t key_len;
	const char *p;
	int i;
	int n;

	key_len = strlen(key);
	if (key_len <= data->dirdepth ||
		buflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {
		return NULL;
	}

	p = key;
	memcpy(buf, data->basedir, data->basedir_len);
	n = data->basedir_len;
	buf[n++] = PHP_DIR_SEPARATOR;
	for (i = 0; i < (int)data->dirdepth; i++) {
		buf[n++] = *p++;
		buf[n++] = PHP_DIR_SEPARATOR;
	}
	memcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);
	n += sizeof(FILE_PREFIX) - 1;
	memcpy(buf + n, key, key_len);
	n += key_len;
 
                ps_files_close(data);
 
               if (!ps_files_valid_key(key)) {
                        php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
                       PS(invalid_session_id) = 1;
                        return;
                }
                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
                        return;
                }
	if (data->fd != -1) {
#ifdef PHP_WIN32
		/* On Win32 locked files that are closed without being explicitly unlocked
		   will be unlocked only when ""system resources become available"". */
		flock(data->fd, LOCK_UN);
#endif
		close(data->fd);
		data->fd = -1;
	}
}

static void ps_files_open(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];

	if (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {
		if (data->lastkey) {
			efree(data->lastkey);
			data->lastkey = NULL;
		}

		ps_files_close(data);

		if (!ps_files_valid_key(key)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
			PS(invalid_session_id) = 1;
			return;
		}
		if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
			return;
		}

		data->lastkey = estrdup(key);

		data->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);

		if (data->fd != -1) {
#ifndef PHP_WIN32
			/* check to make sure that the opened file is not a symlink, linking to data outside of allowable dirs */
			if (PG(open_basedir)) {
				struct stat sbuf;

				if (fstat(data->fd, &sbuf)) {
					close(data->fd);
					return;
				}
				if (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {
					close(data->fd);
					return;
				}
			}
#endif
			flock(data->fd, LOCK_EX);

#ifdef F_SETFD
# ifndef FD_CLOEXEC
#  define FD_CLOEXEC 1
# endif
			if (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)"", data->fd, strerror(errno), errno);
			}
#endif
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""open(%s, O_RDWR) failed: %s (%d)"", buf, strerror(errno), errno);
		}
	}
}

static int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)
{
	DIR *dir;
	char dentry[sizeof(struct dirent) + MAXPATHLEN];
	struct dirent *entry = (struct dirent *) &dentry;
	struct stat sbuf;
	char buf[MAXPATHLEN];
	time_t now;
	int nrdels = 0;
	size_t dirname_len;

	dir = opendir(dirname);
	if (!dir) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ps_files_cleanup_dir: opendir(%s) failed: %s (%d)"", dirname, strerror(errno), errno);
		return (0);
	}

	time(&now);

        return (nrdels);
 }
 
 #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()
 
 PS_OPEN_FUNC(files)
						(now - sbuf.st_mtime) > maxlifetime) {
					VCWD_UNLINK(buf);
					nrdels++;
				}
			}
",C,"               if (php_session_valid_key(key) == FAILURE) {

static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
       char buf[MAXPATHLEN];
       struct stat sbuf;

       if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
               return FAILURE;
       }
       if (VCWD_STAT(buf, &sbuf)) {
               return FAILURE;
       }
       return SUCCESS;
}


","               if (!ps_files_valid_key(key)) {
                       PS(invalid_session_id) = 1;
",c793a6569013f9ab46f2cd7331cc1a04aa42cbed,"@@ -61,40 +61,9 @@ typedef struct {
 } ps_files;
 
 ps_module ps_mod_files = {
-       PS_MOD(files)
+       PS_MOD_SID(files)
 };
 
-/* If you change the logic here, please also update the error message in
- * ps_files_open() appropriately */
-static int ps_files_valid_key(const char *key)
-{
-       size_t len;
-       const char *p;
-       char c;
-       int ret = 1;
-
-       for (p = key; (c = *p); p++) {
-               /* valid characters are a..z,A..Z,0..9 */
-               if (!((c >= 'a' && c <= 'z')
-                               || (c >= 'A' && c <= 'Z')
-                               || (c >= '0' && c <= '9')
-                               || c == ','
-                               || c == '-')) {
-                       ret = 0;
-                       break;
-               }
-       }
-
-       len = p - key;
-
-       /* Somewhat arbitrary length limit here, but should be way more than
-          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
-       if (len == 0 || len > 128) {
-               ret = 0;
-       }
-
-       return ret;
-}
 
 static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
 {
@@ -155,11 +124,11 @@ static void ps_files_open(ps_files *data, const char *key TSRMLS_DC)
 
                ps_files_close(data);
 
-               if (!ps_files_valid_key(key)) {
+               if (php_session_valid_key(key) == FAILURE) {
                        php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
-                       PS(invalid_session_id) = 1;
                        return;
                }
+
                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
                        return;
                }
@@ -253,6 +222,21 @@ static int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)
        return (nrdels);
 }
 
+static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
+{
+       char buf[MAXPATHLEN];
+       struct stat sbuf;
+
+       if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
+               return FAILURE;
+       }
+       if (VCWD_STAT(buf, &sbuf)) {
+               return FAILURE;
+       }
+       return SUCCESS;
+}
+
+
 #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()
 
 PS_OPEN_FUNC(files)
@@ -342,6 +326,24 @@ PS_READ_FUNC(files)
        struct stat sbuf;
        PS_FILES_DATA;
 
+       /* If strict mode, check session id existence */
+       if (PS(use_strict_mode) &&
+               ps_files_key_exists(data, key TSRMLS_CC) == FAILURE) {
+               /* key points to PS(id), but cannot change here. */
+               if (key) {
+                       efree(PS(id));
+                       PS(id) = NULL;
+               }
+               PS(id) = PS(mod)->s_create_sid((void **)&data, NULL TSRMLS_CC);
+               if (!PS(id)) {
+                       return FAILURE;
+               }
+               php_session_reset_id(TSRMLS_C);
+               if (PS(use_cookies)) {
+                       PS(send_cookie) = 1;
+               }
+       }
+
        ps_files_open(data, key TSRMLS_CC);
        if (data->fd < 0) {
                return FAILURE;
@@ -454,6 +456,17 @@ PS_GC_FUNC(files)
        return SUCCESS;
 }
 
+PS_CREATE_SID_FUNC(files)
+{
+       char *sid;
+       PS_FILES_DATA;
+
+       sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
+
+       return sid;
+}
+
+
 /*
  * Local variables:
  * tab-width: 4",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/session/mod_files.c;h=e9dc25a4b8ab60b31bfb41202ae3acb1890b1c30;hb=25e8fcc88fa20dc9d4c47184471003f436927cde,https://git.php.net/?p=php-src.git;a=blob;f=ext/session/mod_files.c;h=053c617dec232634059b0c374fee6b15e73c708c," static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
 {
{
	size_t len;
	const char *p;
	char c;
	int ret = 1;

	for (p = key; (c = *p); p++) {
		/* valid characters are a..z,A..Z,0..9 */
		if (!((c >= 'a' && c <= 'z')
				|| (c >= 'A' && c <= 'Z')
				|| (c >= '0' && c <= '9')
				|| c == ','
				|| c == '-')) {
			ret = 0;
			break;
		}
	}

	len = p - key;

	/* Somewhat arbitrary length limit here, but should be way more than
	   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
	if (len == 0 || len > 128) {
		ret = 0;
	}

	return ret;
}

static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)
{
	size_t key_len;
	const char *p;
	int i;
	int n;

	key_len = strlen(key);
	if (key_len <= data->dirdepth ||
		buflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {
		return NULL;
	}

	p = key;
	memcpy(buf, data->basedir, data->basedir_len);
	n = data->basedir_len;
	buf[n++] = PHP_DIR_SEPARATOR;
	for (i = 0; i < (int)data->dirdepth; i++) {
		buf[n++] = *p++;
		buf[n++] = PHP_DIR_SEPARATOR;
	}
	memcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);
	n += sizeof(FILE_PREFIX) - 1;
	memcpy(buf + n, key, key_len);
	n += key_len;
 
                ps_files_close(data);
 
//flaw_line_below:
               if (!ps_files_valid_key(key)) {
//fix_flaw_line_below:
//               if (php_session_valid_key(key) == FAILURE) {
                        php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
//flaw_line_below:
                       PS(invalid_session_id) = 1;
                        return;
                }
//fix_flaw_line_below:
//
                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
                        return;
                }
	if (data->fd != -1) {
#ifdef PHP_WIN32
		/* On Win32 locked files that are closed without being explicitly unlocked
		   will be unlocked only when ""system resources become available"". */
		flock(data->fd, LOCK_UN);
#endif
		close(data->fd);
		data->fd = -1;
	}
}

static void ps_files_open(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];

	if (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {
		if (data->lastkey) {
			efree(data->lastkey);
			data->lastkey = NULL;
		}

		ps_files_close(data);

		if (!ps_files_valid_key(key)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'"");
			PS(invalid_session_id) = 1;
			return;
		}
		if (!ps_files_path_create(buf, sizeof(buf), data, key)) {
			return;
		}

		data->lastkey = estrdup(key);

		data->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);

		if (data->fd != -1) {
#ifndef PHP_WIN32
			/* check to make sure that the opened file is not a symlink, linking to data outside of allowable dirs */
			if (PG(open_basedir)) {
				struct stat sbuf;

				if (fstat(data->fd, &sbuf)) {
					close(data->fd);
					return;
				}
				if (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {
					close(data->fd);
					return;
				}
			}
#endif
			flock(data->fd, LOCK_EX);

#ifdef F_SETFD
# ifndef FD_CLOEXEC
#  define FD_CLOEXEC 1
# endif
			if (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)"", data->fd, strerror(errno), errno);
			}
#endif
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""open(%s, O_RDWR) failed: %s (%d)"", buf, strerror(errno), errno);
		}
	}
}

static int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)
{
	DIR *dir;
	char dentry[sizeof(struct dirent) + MAXPATHLEN];
	struct dirent *entry = (struct dirent *) &dentry;
	struct stat sbuf;
	char buf[MAXPATHLEN];
	time_t now;
	int nrdels = 0;
	size_t dirname_len;

	dir = opendir(dirname);
	if (!dir) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ps_files_cleanup_dir: opendir(%s) failed: %s (%d)"", dirname, strerror(errno), errno);
		return (0);
	}

	time(&now);

        return (nrdels);
 }
 
//fix_flaw_line_below:
//static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//       char buf[MAXPATHLEN];
//fix_flaw_line_below:
//       struct stat sbuf;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//       if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
//fix_flaw_line_below:
//               return FAILURE;
//fix_flaw_line_below:
//       }
//fix_flaw_line_below:
//       if (VCWD_STAT(buf, &sbuf)) {
//fix_flaw_line_below:
//               return FAILURE;
//fix_flaw_line_below:
//       }
//fix_flaw_line_below:
//       return SUCCESS;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
 #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()
 
 PS_OPEN_FUNC(files)
						(now - sbuf.st_mtime) > maxlifetime) {
					VCWD_UNLINK(buf);
					nrdels++;
				}
			}
",               if (!ps_files_valid_key(key)) {/~/                       PS(invalid_session_id) = 1;,"59,61",True
11.0,185961,"static void CloudPrintInfoCallback(bool enabled,
                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
}
",1,None,Remote,Not required,Partial,CVE-2016-5149,https://www.cvedetails.com/cve/CVE-2016-5149/,CWE-94,Medium,Partial,Partial,,11/09/2016,6.8,"The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL.",30/10/2018,,4.0,https://github.com/chromium/chromium/commit/53262b5285efbbfdbbcc17fbf5200890f1ee295c,53262b5285efbbfdbbcc17fbf5200890f1ee295c,"Migrate ServiceProcessControl tests off of QuitCurrent*Deprecated().

Bug: 844016
Change-Id: I9403b850456c8ee06cd2539f7cec9599302e81a0
Reviewed-on: https://chromium-review.googlesource.com/1126576
Commit-Queue: Wez <wez@chromium.org>
Reviewed-by: Avi Drissman <avi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#573131}",3.0,chrome/browser/service_process/service_process_control_browsertest.cc,"{""sha"": ""0a04df0fa30f33bb4c1a9e7fa461ecce6c6aad83"", ""filename"": ""chrome/browser/service_process/service_process_control_browsertest.cc"", ""status"": ""modified"", ""additions"": 107, ""deletions"": 87, ""changes"": 194, ""blob_url"": ""https://github.com/chromium/chromium/blob/53262b5285efbbfdbbcc17fbf5200890f1ee295c/chrome/browser/service_process/service_process_control_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/53262b5285efbbfdbbcc17fbf5200890f1ee295c/chrome/browser/service_process/service_process_control_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/service_process/service_process_control_browsertest.cc?ref=53262b5285efbbfdbbcc17fbf5200890f1ee295c"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/service_process/service_process_control.h\""\n \n+#include \""base/barrier_closure.h\""\n #include \""base/bind.h\""\n #include \""base/bind_helpers.h\""\n #include \""base/command_line.h\""\n@@ -37,36 +38,29 @@ class ServiceProcessControlBrowserTest\n   }\n   ~ServiceProcessControlBrowserTest() override {}\n \n-  void HistogramsCallback() {\n+  void HistogramsCallback(base::RepeatingClosure on_done) {\n     MockHistogramsCallback();\n-    QuitMessageLoop();\n+    on_done.Run();\n   }\n \n   MOCK_METHOD0(MockHistogramsCallback, void());\n \n  protected:\n-  void LaunchServiceProcessControl(bool wait) {\n+  void LaunchServiceProcessControl(base::RepeatingClosure on_launched) {\n     // Launch the process asynchronously.\n     ServiceProcessControl::GetInstance()->Launch(\n-        base::Bind(&ServiceProcessControlBrowserTest::ProcessControlLaunched,\n-                   base::Unretained(this)),\n-        base::Bind(\n+        base::BindOnce(\n+            &ServiceProcessControlBrowserTest::ProcessControlLaunched,\n+            base::Unretained(this), on_launched),\n+        base::BindOnce(\n             &ServiceProcessControlBrowserTest::ProcessControlLaunchFailed,\n-            base::Unretained(this)));\n-\n-    // Then run the message loop to keep things running.\n-    if (wait)\n-      content::RunMessageLoop();\n-  }\n-\n-  static void QuitMessageLoop() {\n-    base::RunLoop::QuitCurrentWhenIdleDeprecated();\n+            base::Unretained(this), on_launched));\n   }\n \n-  static void CloudPrintInfoCallback(bool enabled,\n-                                     const std::string& email,\n-                                     const std::string& proxy_id) {\n-    QuitMessageLoop();\n+  void LaunchServiceProcessControlAndWait() {\n+    base::RunLoop run_loop;\n+    LaunchServiceProcessControl(run_loop.QuitClosure());\n+    run_loop.Run();\n   }\n \n   void Disconnect() {\n@@ -101,7 +95,7 @@ class ServiceProcessControlBrowserTest\n     InProcessBrowserTest::TearDown();\n   }\n \n-  void ProcessControlLaunched() {\n+  void ProcessControlLaunched(base::OnceClosure on_done) {\n     base::ScopedAllowBlockingForTesting allow_blocking;\n     base::ProcessId service_pid;\n     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));\n@@ -114,18 +108,12 @@ class ServiceProcessControlBrowserTest\n     service_process_ = base::Process::Open(service_pid);\n #endif\n     EXPECT_TRUE(service_process_.IsValid());\n-    // Quit the current message. Post a QuitTask instead of just calling Quit()\n-    // because this can get invoked in the context of a Launch() call and we\n-    // may not be in Run() yet.\n-    base::ThreadTaskRunnerHandle::Get()->PostTask(\n-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+    std::move(on_done).Run();\n   }\n \n-  void ProcessControlLaunchFailed() {\n+  void ProcessControlLaunchFailed(base::OnceClosure on_done) {\n     ADD_FAILURE();\n-    // Quit the current message.\n-    base::ThreadTaskRunnerHandle::Get()->PostTask(\n-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+    std::move(on_done).Run();\n   }\n \n  private:\n@@ -152,39 +140,45 @@ class RealServiceProcessControlBrowserTest\n // TODO(vitalybuka): Fix crbug.com/340563\n IN_PROC_BROWSER_TEST_F(RealServiceProcessControlBrowserTest,\n                        DISABLED_LaunchAndIPC) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n+  base::RunLoop run_loop;\n   cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                        const std::string&) { std::move(done).Run(); },\n+                     run_loop.QuitClosure()));\n+  run_loop.Run();\n \n   // And then shutdown the service process.\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n }\n \n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndIPC) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n+  base::RunLoop run_loop;\n   cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                        const std::string&) { std::move(done).Run(); },\n+                     run_loop.QuitClosure()));\n+  run_loop.Run();\n \n   // And then shutdown the service process.\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n }\n \n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n@@ -197,21 +191,34 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {\n \n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n-  Disconnect();\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+    Disconnect();\n+  }\n \n-  LaunchServiceProcessControl(false);\n+  {\n+    base::RunLoop run_loop;\n+    LaunchServiceProcessControl(run_loop.QuitClosure());\n \n-  ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n-  content::RunMessageLoop();\n+    ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n+    run_loop.Run();\n+  }\n \n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+  }\n \n   // And then shutdown the service process.\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n@@ -227,32 +234,35 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {\n #endif\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_LaunchTwice) {\n   // Launch the service process the first time.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n \n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+  }\n \n   // Launch the service process again.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(\n       &cloud_print_proxy);\n-  cloud_print_proxy->GetCloudPrintProxyInfo(\n-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));\n-  content::RunMessageLoop();\n-}\n-\n-static void DecrementUntilZero(int* count) {\n-  (*count)--;\n-  if (!(*count))\n-    base::ThreadTaskRunnerHandle::Get()->PostTask(\n-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+  {\n+    base::RunLoop run_loop;\n+    cloud_print_proxy->GetCloudPrintProxyInfo(\n+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,\n+                          const std::string&) { std::move(done).Run(); },\n+                       run_loop.QuitClosure()));\n+    run_loop.Run();\n+  }\n }\n \n // Flaky on Mac. http://crbug.com/517420\n@@ -266,15 +276,23 @@ static void DecrementUntilZero(int* count) {\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n                        MAYBE_MultipleLaunchTasks) {\n   ServiceProcessControl* process = ServiceProcessControl::GetInstance();\n-  int launch_count = 5;\n-  for (int i = 0; i < launch_count; i++) {\n+  constexpr int kExpectedLaunchCount = 5;\n+  int success_count = 0;\n+  base::RunLoop run_loop;\n+  base::RepeatingClosure on_launch_attempted =\n+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());\n+  for (int i = 0; i < kExpectedLaunchCount; i++) {\n     // Launch the process asynchronously.\n-    process->Launch(base::Bind(&DecrementUntilZero, &launch_count),\n-                    base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n+    process->Launch(base::BindOnce(\n+                        [](int* success_count, base::OnceClosure task) {\n+                          (*success_count)++;\n+                          std::move(task).Run();\n+                        },\n+                        &success_count, on_launch_attempted),\n+                    on_launch_attempted);\n   }\n-  // Then run the message loop to keep things running.\n-  content::RunMessageLoop();\n-  EXPECT_EQ(0, launch_count);\n+  run_loop.Run();\n+  EXPECT_EQ(kExpectedLaunchCount, success_count);\n }\n \n // Flaky on Mac. http://crbug.com/517420\n@@ -286,15 +304,15 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n // Make sure using the same task for success and failure tasks works.\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {\n   ServiceProcessControl* process = ServiceProcessControl::GetInstance();\n-  int launch_count = 5;\n-  for (int i = 0; i < launch_count; i++) {\n+  constexpr int kExpectedLaunchCount = 5;\n+  base::RunLoop run_loop;\n+  base::RepeatingClosure task =\n+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());\n+  for (int i = 0; i < kExpectedLaunchCount; i++) {\n     // Launch the process asynchronously.\n-    base::Closure task = base::Bind(&DecrementUntilZero, &launch_count);\n     process->Launch(task, task);\n   }\n-  // Then run the message loop to keep things running.\n-  content::RunMessageLoop();\n-  EXPECT_EQ(0, launch_count);\n+  run_loop.Run();\n }\n \n // Tests whether disconnecting from the service IPC causes the service process\n@@ -308,7 +326,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n                        MAYBE_DieOnDisconnect) {\n   // Launch the service process.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   Disconnect();\n@@ -322,7 +340,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n #endif\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_ForceShutdown) {\n   // Launch the service process.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   // Make sure we are connected to the service process.\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   base::ProcessId service_pid;\n@@ -343,7 +361,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_CheckPid) {\n   base::ScopedAllowBlockingForTesting allow_blocking;\n   EXPECT_FALSE(GetServiceProcessData(NULL, &service_pid));\n   // Launch the service process.\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));\n   EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);\n   // Disconnect from service process.\n@@ -354,8 +372,8 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {\n   ASSERT_FALSE(ServiceProcessControl::GetInstance()->IsConnected());\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);\n   EXPECT_FALSE(ServiceProcessControl::GetInstance()->GetHistograms(\n-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,\n-                 base::Unretained(this)),\n+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,\n+                          base::Unretained(this), base::DoNothing()),\n       base::TimeDelta()));\n }\n \n@@ -369,29 +387,31 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {\n #endif\n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,\n                        MAYBE_HistogramsTimeout) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   // Callback should not be called during GetHistograms call.\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);\n+  base::RunLoop run_loop;\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(\n-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,\n-                 base::Unretained(this)),\n+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,\n+                          base::Unretained(this), run_loop.QuitClosure()),\n       base::TimeDelta::FromMilliseconds(100)));\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());\n-  content::RunMessageLoop();\n+  run_loop.Run();\n }\n \n IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_Histograms) {\n-  LaunchServiceProcessControl(true);\n+  LaunchServiceProcessControlAndWait();\n   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());\n   // Callback should not be called during GetHistograms call.\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);\n   // Wait for real callback by providing large timeout value.\n+  base::RunLoop run_loop;\n   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(\n-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,\n-                base::Unretained(this)),\n+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,\n+                          base::Unretained(this), run_loop.QuitClosure()),\n       base::TimeDelta::FromHours(1)));\n   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);\n-  content::RunMessageLoop();\n+  run_loop.Run();\n }""}","  static void CloudPrintInfoCallback(bool enabled,
  void LaunchServiceProcessControlAndWait() {
    base::RunLoop run_loop;
    LaunchServiceProcessControl(run_loop.QuitClosure());
    run_loop.Run();
   }
","  static void CloudPrintInfoCallback(bool enabled,
                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
   }
",C,"  void LaunchServiceProcessControlAndWait() {
    base::RunLoop run_loop;
    LaunchServiceProcessControl(run_loop.QuitClosure());
    run_loop.Run();
","                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
",,"@@ -4,6 +4,7 @@
 
 #include ""chrome/browser/service_process/service_process_control.h""
 
+#include ""base/barrier_closure.h""
 #include ""base/bind.h""
 #include ""base/bind_helpers.h""
 #include ""base/command_line.h""
@@ -37,36 +38,29 @@ class ServiceProcessControlBrowserTest
   }
   ~ServiceProcessControlBrowserTest() override {}
 
-  void HistogramsCallback() {
+  void HistogramsCallback(base::RepeatingClosure on_done) {
     MockHistogramsCallback();
-    QuitMessageLoop();
+    on_done.Run();
   }
 
   MOCK_METHOD0(MockHistogramsCallback, void());
 
  protected:
-  void LaunchServiceProcessControl(bool wait) {
+  void LaunchServiceProcessControl(base::RepeatingClosure on_launched) {
     // Launch the process asynchronously.
     ServiceProcessControl::GetInstance()->Launch(
-        base::Bind(&ServiceProcessControlBrowserTest::ProcessControlLaunched,
-                   base::Unretained(this)),
-        base::Bind(
+        base::BindOnce(
+            &ServiceProcessControlBrowserTest::ProcessControlLaunched,
+            base::Unretained(this), on_launched),
+        base::BindOnce(
             &ServiceProcessControlBrowserTest::ProcessControlLaunchFailed,
-            base::Unretained(this)));
-
-    // Then run the message loop to keep things running.
-    if (wait)
-      content::RunMessageLoop();
-  }
-
-  static void QuitMessageLoop() {
-    base::RunLoop::QuitCurrentWhenIdleDeprecated();
+            base::Unretained(this), on_launched));
   }
 
-  static void CloudPrintInfoCallback(bool enabled,
-                                     const std::string& email,
-                                     const std::string& proxy_id) {
-    QuitMessageLoop();
+  void LaunchServiceProcessControlAndWait() {
+    base::RunLoop run_loop;
+    LaunchServiceProcessControl(run_loop.QuitClosure());
+    run_loop.Run();
   }
 
   void Disconnect() {
@@ -101,7 +95,7 @@ class ServiceProcessControlBrowserTest
     InProcessBrowserTest::TearDown();
   }
 
-  void ProcessControlLaunched() {
+  void ProcessControlLaunched(base::OnceClosure on_done) {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
@@ -114,18 +108,12 @@ class ServiceProcessControlBrowserTest
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
-    // Quit the current message. Post a QuitTask instead of just calling Quit()
-    // because this can get invoked in the context of a Launch() call and we
-    // may not be in Run() yet.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+    std::move(on_done).Run();
   }
 
-  void ProcessControlLaunchFailed() {
+  void ProcessControlLaunchFailed(base::OnceClosure on_done) {
     ADD_FAILURE();
-    // Quit the current message.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+    std::move(on_done).Run();
   }
 
  private:
@@ -152,39 +140,45 @@ class RealServiceProcessControlBrowserTest
 // TODO(vitalybuka): Fix crbug.com/340563
 IN_PROC_BROWSER_TEST_F(RealServiceProcessControlBrowserTest,
                        DISABLED_LaunchAndIPC) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
+  base::RunLoop run_loop;
   cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                        const std::string&) { std::move(done).Run(); },
+                     run_loop.QuitClosure()));
+  run_loop.Run();
 
   // And then shutdown the service process.
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndIPC) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
+  base::RunLoop run_loop;
   cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+      base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                        const std::string&) { std::move(done).Run(); },
+                     run_loop.QuitClosure()));
+  run_loop.Run();
 
   // And then shutdown the service process.
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
@@ -197,21 +191,34 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
 
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
-  Disconnect();
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+    Disconnect();
+  }
 
-  LaunchServiceProcessControl(false);
+  {
+    base::RunLoop run_loop;
+    LaunchServiceProcessControl(run_loop.QuitClosure());
 
-  ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
-  content::RunMessageLoop();
+    ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
+    run_loop.Run();
+  }
 
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+  }
 
   // And then shutdown the service process.
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
@@ -227,32 +234,35 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_LaunchTwice) {
   // Launch the service process the first time.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
 
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+  }
 
   // Launch the service process again.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
-  cloud_print_proxy->GetCloudPrintProxyInfo(
-      base::Bind(&ServiceProcessControlBrowserTest::CloudPrintInfoCallback));
-  content::RunMessageLoop();
-}
-
-static void DecrementUntilZero(int* count) {
-  (*count)--;
-  if (!(*count))
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+  {
+    base::RunLoop run_loop;
+    cloud_print_proxy->GetCloudPrintProxyInfo(
+        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
+                          const std::string&) { std::move(done).Run(); },
+                       run_loop.QuitClosure()));
+    run_loop.Run();
+  }
 }
 
 // Flaky on Mac. http://crbug.com/517420
@@ -266,15 +276,23 @@ static void DecrementUntilZero(int* count) {
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_MultipleLaunchTasks) {
   ServiceProcessControl* process = ServiceProcessControl::GetInstance();
-  int launch_count = 5;
-  for (int i = 0; i < launch_count; i++) {
+  constexpr int kExpectedLaunchCount = 5;
+  int success_count = 0;
+  base::RunLoop run_loop;
+  base::RepeatingClosure on_launch_attempted =
+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());
+  for (int i = 0; i < kExpectedLaunchCount; i++) {
     // Launch the process asynchronously.
-    process->Launch(base::Bind(&DecrementUntilZero, &launch_count),
-                    base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
+    process->Launch(base::BindOnce(
+                        [](int* success_count, base::OnceClosure task) {
+                          (*success_count)++;
+                          std::move(task).Run();
+                        },
+                        &success_count, on_launch_attempted),
+                    on_launch_attempted);
   }
-  // Then run the message loop to keep things running.
-  content::RunMessageLoop();
-  EXPECT_EQ(0, launch_count);
+  run_loop.Run();
+  EXPECT_EQ(kExpectedLaunchCount, success_count);
 }
 
 // Flaky on Mac. http://crbug.com/517420
@@ -286,15 +304,15 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
 // Make sure using the same task for success and failure tasks works.
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {
   ServiceProcessControl* process = ServiceProcessControl::GetInstance();
-  int launch_count = 5;
-  for (int i = 0; i < launch_count; i++) {
+  constexpr int kExpectedLaunchCount = 5;
+  base::RunLoop run_loop;
+  base::RepeatingClosure task =
+      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());
+  for (int i = 0; i < kExpectedLaunchCount; i++) {
     // Launch the process asynchronously.
-    base::Closure task = base::Bind(&DecrementUntilZero, &launch_count);
     process->Launch(task, task);
   }
-  // Then run the message loop to keep things running.
-  content::RunMessageLoop();
-  EXPECT_EQ(0, launch_count);
+  run_loop.Run();
 }
 
 // Tests whether disconnecting from the service IPC causes the service process
@@ -308,7 +326,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_DieOnDisconnect) {
   // Launch the service process.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   Disconnect();
@@ -322,7 +340,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_ForceShutdown) {
   // Launch the service process.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   // Make sure we are connected to the service process.
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   base::ProcessId service_pid;
@@ -343,7 +361,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_CheckPid) {
   base::ScopedAllowBlockingForTesting allow_blocking;
   EXPECT_FALSE(GetServiceProcessData(NULL, &service_pid));
   // Launch the service process.
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
   EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
   // Disconnect from service process.
@@ -354,8 +372,8 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {
   ASSERT_FALSE(ServiceProcessControl::GetInstance()->IsConnected());
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
   EXPECT_FALSE(ServiceProcessControl::GetInstance()->GetHistograms(
-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,
-                 base::Unretained(this)),
+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
+                          base::Unretained(this), base::DoNothing()),
       base::TimeDelta()));
 }
 
@@ -369,29 +387,31 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_HistogramsTimeout) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   // Callback should not be called during GetHistograms call.
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
+  base::RunLoop run_loop;
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(
-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,
-                 base::Unretained(this)),
+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
+                          base::Unretained(this), run_loop.QuitClosure()),
       base::TimeDelta::FromMilliseconds(100)));
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
-  content::RunMessageLoop();
+  run_loop.Run();
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_Histograms) {
-  LaunchServiceProcessControl(true);
+  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   // Callback should not be called during GetHistograms call.
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
   // Wait for real callback by providing large timeout value.
+  base::RunLoop run_loop;
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(
-      base::Bind(&ServiceProcessControlBrowserTest::HistogramsCallback,
-                base::Unretained(this)),
+      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
+                          base::Unretained(this), run_loop.QuitClosure()),
       base::TimeDelta::FromHours(1)));
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);
-  content::RunMessageLoop();
+  run_loop.Run();
 }",Chrome,53262b5285efbbfdbbcc17fbf5200890f1ee295c,56016bcf9add262d12ea2badcee26e972f8beab5,"  static void CloudPrintInfoCallback(bool enabled,
//flaw_line_below:
                                     const std::string& email,
//flaw_line_below:
                                     const std::string& proxy_id) {
//flaw_line_below:
    QuitMessageLoop();
//fix_flaw_line_below:
//  void LaunchServiceProcessControlAndWait() {
//fix_flaw_line_below:
//    base::RunLoop run_loop;
//fix_flaw_line_below:
//    LaunchServiceProcessControl(run_loop.QuitClosure());
//fix_flaw_line_below:
//    run_loop.Run();
   }
","                                     const std::string& email,/~/                                     const std::string& proxy_id) {/~/    QuitMessageLoop();","1,2,3",False
63.0,121151,"Decimal HTMLInputElement::findClosestTickMarkValue(const Decimal& value)
{
    return m_inputType->findClosestTickMarkValue(value);
}
",0,None,Remote,Not required,Partial,CVE-2013-2871,https://www.cvedetails.com/cve/CVE-2013-2871/,CWE-20,Low,Partial,Partial,,10/07/2013,7.5,Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of input.,18/09/2017,DoS ,0.0,https://github.com/chromium/chromium/commit/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9,bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9,"Setting input.x-webkit-speech should not cause focus change

In r150866, we introduced element()->focus() in destroyShadowSubtree()
to retain focus on <input> when its type attribute gets changed.
But when x-webkit-speech attribute is changed, the element is detached
before calling destroyShadowSubtree() and element()->focus() failed
This patch moves detach() after destroyShadowSubtree() to fix the
problem.

BUG=243818
TEST=fast/forms/input-type-change-focusout.html
NOTRY=true

Review URL: https://chromiumcodereview.appspot.com/16084005

git-svn-id: svn://svn.chromium.org/blink/trunk@151444 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0.0,third_party/WebKit/Source/core/html/HTMLInputElement.cpp,"{""sha"": ""f827f9e1b00949970f144f1ada308ccfecbe4cc6"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout-expected.txt?ref=bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9"", ""patch"": ""@@ -1,4 +1,4 @@\n-This tests that changing an input element's type does not cause focusout event.\n+This tests that changing an input element's type or speech attribute does not cause focusout event.\n \n On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\"".\n \n@@ -8,6 +8,7 @@ PASS focusoutCalled is false\n PASS focusoutCalled is false\n PASS focusoutCalled is false\n PASS focusoutCalled is false\n+PASS focusoutCalled is false\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""640b129674f29bfe200773352e9dc85b6c9e2be9"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout.html"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/input-type-change-focusout.html?ref=bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9"", ""patch"": ""@@ -5,14 +5,16 @@\n <body>\n <input id=\""input\"" type='date' />\n <script>\n-description(\""This tests that changing an input element's type does not cause focusout event.\"");\n+description(\""This tests that changing an input element's type or speech attribute does not cause focusout event.\"");\n \n focusoutCalled = false;\n \n input.addEventListener('focusout', function() {\n     focusoutCalled = true;\n });\n input.focus();\n+input.setAttribute('x-webkit-speech');\n+shouldBeFalse('focusoutCalled');\n input.type = 'month';\n shouldBeFalse('focusoutCalled');\n input.type = 'week';""}<_**next**_>{""sha"": ""4f1400a697901bc8ba8228bea6379345049bf025"", ""filename"": ""third_party/WebKit/Source/core/html/BaseMultipleFieldsDateAndTimeInputType.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/Source/core/html/BaseMultipleFieldsDateAndTimeInputType.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/Source/core/html/BaseMultipleFieldsDateAndTimeInputType.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/BaseMultipleFieldsDateAndTimeInputType.cpp?ref=bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9"", ""patch"": ""@@ -289,6 +289,11 @@ void BaseMultipleFieldsDateAndTimeInputType::createShadowSubtree()\n {\n     ASSERT(element()->shadow());\n \n+    // Element must not be attached here, because if it was attached\n+    // DateTimeEditElement::customStyleForRenderer() is called in appendChild()\n+    // before the field wrapper element is created.\n+    ASSERT(!element()->attached());\n+\n     Document* document = element()->document();\n     ContainerNode* container = element()->userAgentShadowRoot();\n ""}<_**next**_>{""sha"": ""6c98ca305e6c326f2a8cf5a06d2dbc1bc2358b2d"", ""filename"": ""third_party/WebKit/Source/core/html/HTMLInputElement.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/Source/core/html/HTMLInputElement.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9/third_party/WebKit/Source/core/html/HTMLInputElement.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/HTMLInputElement.cpp?ref=bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9"", ""patch"": ""@@ -775,8 +775,8 @@ void HTMLInputElement::parseAttribute(const QualifiedName& name, const AtomicStr\n             // This renderer and its children have quite different layouts and styles depending on\n             // whether the speech button is visible or not. So we reset the whole thing and recreate\n             // to get the right styles and layout.\n-            detach();\n             m_inputType->destroyShadowSubtree();\n+            detach();\n             m_inputType->createShadowSubtree();\n             if (!attached())\n                 attach();""}","Decimal HTMLInputElement::findClosestTickMarkValue(const Decimal& value)
{
    return m_inputType->findClosestTickMarkValue(value);
}
","Decimal HTMLInputElement::findClosestTickMarkValue(const Decimal& value)
{
    return m_inputType->findClosestTickMarkValue(value);
}
",C,,,,"@@ -775,8 +775,8 @@ void HTMLInputElement::parseAttribute(const QualifiedName& name, const AtomicStr
             // This renderer and its children have quite different layouts and styles depending on
             // whether the speech button is visible or not. So we reset the whole thing and recreate
             // to get the right styles and layout.
-            detach();
             m_inputType->destroyShadowSubtree();
+            detach();
             m_inputType->createShadowSubtree();
             if (!attached())
                 attach();",Chrome,bb9cfb0aba25f4b13e57bdd4a9fac80ba071e7b9,782ae8becea80992a90e1515868fa28a8b608523,"Decimal HTMLInputElement::findClosestTickMarkValue(const Decimal& value)
{
    return m_inputType->findClosestTickMarkValue(value);
}
",,,False
73.0,94694,"int i2d_X509_bio(BIO *bp, X509 *x509)
	{
	return ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);
	}
",0,None,Remote,Not required,None,CVE-2014-8275,https://www.cvedetails.com/cve/CVE-2014-8275/,CWE-310,Low,None,Partial,,08/01/2015,5.0,"OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",14/11/2017,,0.0,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,684400ce192dac51df3d3e92b61830a6ef90be3e,"Fix various certificate fingerprint issues.

By using non-DER or invalid encodings outside the signed portion of a
certificate the fingerprint can be changed without breaking the signature.
Although no details of the signed portion of the certificate can be changed
this can cause problems with some applications: e.g. those using the
certificate fingerprint for blacklists.

1. Reject signatures with non zero unused bits.

If the BIT STRING containing the signature has non zero unused bits reject
the signature. All current signature algorithms require zero unused bits.

2. Check certificate algorithm consistency.

Check the AlgorithmIdentifier inside TBS matches the one in the
certificate signature. NB: this will result in signature failure
errors for some broken certificates.

3. Check DSA/ECDSA signatures use DER.

Reencode DSA/ECDSA signatures and compare with the original received
signature. Return an error if there is a mismatch.

This will reject various cases including garbage after signature
(thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS
program for discovering this case) and use of BER or invalid ASN.1 INTEGERs
(negative or with leading zeroes).

CVE-2014-8275
Reviewed-by: Emilia Ksper <emilia@openssl.org>",0.0,crypto/x509/x_all.c,"{""sha"": ""c076df8f2ec39fe6e54336bf886ec8e7d518c332"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -659,6 +659,43 @@\n \n  Changes between 1.0.1j and 1.0.1k [xx XXX xxxx]\n \n+  *) Fix various certificate fingerprint issues.\n+\n+     By using non-DER or invalid encodings outside the signed portion of a\n+     certificate the fingerprint can be changed without breaking the signature.\n+     Although no details of the signed portion of the certificate can be changed\n+     this can cause problems with some applications: e.g. those using the\n+     certificate fingerprint for blacklists.\n+\n+     1. Reject signatures with non zero unused bits.\n+\n+     If the BIT STRING containing the signature has non zero unused bits reject\n+     the signature. All current signature algorithms require zero unused bits.\n+\n+     2. Check certificate algorithm consistency.\n+\n+     Check the AlgorithmIdentifier inside TBS matches the one in the\n+     certificate signature. NB: this will result in signature failure\n+     errors for some broken certificates.\n+\n+     Thanks to Konrad Kraszewski from Google for reporting this issue.\n+\n+     3. Check DSA/ECDSA signatures use DER.\n+\n+     Reencode DSA/ECDSA signatures and compare with the original received\n+     signature. Return an error if there is a mismatch.\n+\n+     This will reject various cases including garbage after signature\n+     (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS\n+     program for discovering this case) and use of BER or invalid ASN.1 INTEGERs\n+     (negative or with leading zeroes).\n+\n+     Further analysis was conducted and fixes were developed by Stephen Henson\n+     of the OpenSSL core team.\n+\n+     (CVE-2014-8275)\n+     [Steve Henson]\n+\n    *) Do not resume sessions on the server if the negotiated protocol\n       version does not match the session's version. Resuming with a different\n       version, while not strictly forbidden by the RFC, is of questionable""}<_**next**_>{""sha"": ""fdeeef6761e65fdd2b3c28deea66a52f4233354d"", ""filename"": ""crypto/asn1/a_verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/asn1/a_verify.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n \t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n \t\tgoto err;\n \t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tgoto err;\n+\t\t}\n \t\n \tinl=i2d(data,NULL);\n \tbuf_in=OPENSSL_malloc((unsigned int)inl);\n@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n \t\treturn -1;\n \t\t}\n \n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\treturn -1;\n+\t\t}\n+\n \tEVP_MD_CTX_init(&ctx);\n \n \t/* Convert signature OID into digest and public key OIDs */""}<_**next**_>{""sha"": ""58559e54b1ece20eab0a04fdf475ac139e1fa65a"", ""filename"": ""crypto/dsa/dsa_asn1.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/dsa/dsa_asn1.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -177,13 +177,25 @@ int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n \t{\n \tDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = DSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n+\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_DSA_SIG(s, &der);\n+\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=DSA_do_verify(dgst,dgst_len,s,dsa);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""7191b8ab0aea2c3631c1504fdc810a7364d98d56"", ""filename"": ""crypto/ecdsa/ecs_vrf.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/ecdsa/ecs_vrf.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -57,6 +57,7 @@\n  */\n \n #include \""ecs_locl.h\""\n+#include \""cryptlib.h\""\n #ifndef OPENSSL_NO_ENGINE\n #include <openssl/engine.h>\n #endif\n@@ -86,13 +87,25 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n  \t{\n \tECDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = ECDSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n+\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_ECDSA_SIG(s, &der);\n+\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tECDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""d7229506f644e8b52b2203da88909622d1d2417a"", ""filename"": ""crypto/x509/x_all.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/x509/x_all.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -73,6 +73,8 @@\n \n int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n+\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n+\t\treturn 0;\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}""}","int i2d_X509_bio(BIO *bp, X509 *x509)
	{
	return ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);
	}
","int i2d_X509_bio(BIO *bp, X509 *x509)
	{
	return ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);
	}
",C,,,,"@@ -73,6 +73,8 @@
 
 int X509_verify(X509 *a, EVP_PKEY *r)
 	{
+	if (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))
+		return 0;
 	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,
 		a->signature,a->cert_info,r));
 	}",openssl,684400ce192dac51df3d3e92b61830a6ef90be3e,32b07f5a80d22b34cfcd6df76d425bed771b0146,"int i2d_X509_bio(BIO *bp, X509 *x509)
	{
	return ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);
	}
",,,False
72.0,119177,"const AtomicString& XMLHttpRequest::interfaceName() const
{
    return eventNames().interfaceForXMLHttpRequest;
}
",0,None,Remote,Not required,Partial,CVE-2013-2925,https://www.cvedetails.com/cve/CVE-2013-2925/,CWE-399,Medium,Partial,Partial,,16/10/2013,6.8,"Use-after-free vulnerability in core/xml/XMLHttpRequest.cpp in Blink, as used in Google Chrome before 30.0.1599.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger multiple conflicting uses of the same XMLHttpRequest object.",18/09/2017,DoS ,0.0,https://github.com/chromium/chromium/commit/aa1a102f73565feeb1d121d0d6c9524bebcdd75f,aa1a102f73565feeb1d121d0d6c9524bebcdd75f,"Don't dispatch events when XHR is set to sync mode

Any of readystatechange, progress, abort, error, timeout and loadend
event are not specified to be dispatched in sync mode in the latest
spec. Just an exception corresponding to the failure is thrown.

Clean up for readability done in this CL
- factor out dispatchEventAndLoadEnd calling code
- make didTimeout() private
- give error handling methods more descriptive names
- set m_exceptionCode in failure type specific methods
-- Note that for didFailRedirectCheck, m_exceptionCode was not set
   in networkError(), but was set at the end of createRequest()

This CL is prep for fixing crbug.com/292422

BUG=292422

Review URL: https://chromiumcodereview.appspot.com/24225002

git-svn-id: svn://svn.chromium.org/blink/trunk@158046 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0.0,third_party/WebKit/Source/core/xml/XMLHttpRequest.cpp,"{""sha"": ""fad290524dc21258637e70b4b17227be0407ba67"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/connection-error-sync.html"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/connection-error-sync.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/connection-error-sync.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/connection-error-sync.html?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -19,6 +19,14 @@\n         }\n         \n         req.open('GET', 'resources/infinite-loop.php', false);\n+        req.onreadystatechange = function()\n+        {\n+            document.write('onreadystatechange is invoked unexpectedly<br>');\n+        }\n+        req.onerror = function()\n+        {\n+            document.write('onerror is invoked unexpectedly<br>');\n+        }\n         req.send(null);\n \n         document.write(\""Status: \"" + req.status);""}<_**next**_>{""sha"": ""d25741a188c3b0bd49ddce9253c5ed96662fc3a3"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/cross-site-denied-response-sync-2.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/cross-site-denied-response-sync-2.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/cross-site-denied-response-sync-2.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/cross-site-denied-response-sync-2.html?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -46,11 +46,11 @@\n \n var req = new XMLHttpRequest;\n req.open(\""GET\"", \""http://localhost:8000/xmlhttprequest/resources/reply.xml\"", false);\n-req.onerror = stealResponse;\n try {\n     req.send(null);\n     error(\""send did not raise an exception\"");\n } catch (ex) {\n+    stealResponse();\n }\n </script>\n </body>""}<_**next**_>{""sha"": ""38f9ea856c2c435006399845e888c0c2a837af70"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests-expected.txt?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -1,6 +1,6 @@\n Test case for bug 40952: Onloadend event is not supported in XMLHttpRequest\n \n-Verify that a loadend ProgressEvent is dispatched after a load, error, or abort ProgressEvent when a synchronous request completes normally, fails, or is aborted respectively.\n+Verify that a loadend ProgressEvent is dispatched after a load or abort ProgressEvent when a synchronous request completes normally or is aborted respectively.\n \n PASS PASS PASS should appear below:\n ""}<_**next**_>{""sha"": ""50fdf9430c70bedcc4d2289f58e9ff3ccf47595a"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests.html"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/onloadend-event-after-sync-requests.html?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -4,7 +4,7 @@\n </head>\n <body>\n <p> Test case for <a href=\""https://bugs.webkit.org/show_bug.cgi?id=40952\""> bug 40952</a>: Onloadend event is not supported in XMLHttpRequest</p>\n-<p> Verify that a loadend ProgressEvent is dispatched after a load, error, or abort ProgressEvent when a synchronous request completes normally, fails, or is aborted respectively.</p>\n+<p> Verify that a loadend ProgressEvent is dispatched after a load or abort ProgressEvent when a synchronous request completes normally or is aborted respectively.</p>\n <p>PASS PASS PASS should appear below:</p>\n <p id=console></p>\n <script type=\""text/javascript\"">\n@@ -60,9 +60,9 @@\n \n     xhr.onloadstart = logUnexpectedProgressEvent;\n     xhr.onabort = logUnexpectedProgressEvent;\n-    xhr.onerror = logProgressEvent;\n+    xhr.onerror = logUnexpectedProgressEvent;\n     xhr.onload = logUnexpectedProgressEvent;\n-    xhr.onloadend = logProgressEvent;\n+    xhr.onloadend = logUnexpectedProgressEvent;\n \n     xhr.open(\""GET\"", \""resources/infinite-loop.php\"", false); \n     try {\n@@ -73,7 +73,7 @@\n             results += \"" \"" + e;\n     }\n     \n-    completeTest(\"" error loadend\"");\n+    completeTest(\""\"");\n }\n \n function testAbort()""}<_**next**_>{""sha"": ""4f6191a9e649849e9988d22659bbccde236dca2d"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-sync-no-progress-events-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-sync-no-progress-events-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-sync-no-progress-events-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-sync-no-progress-events-expected.txt?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -9,9 +9,6 @@ load\n loadend\n \n Step 2: Cross origin request, disallowed\n-readystatechange 4\n-error\n-loadend\n NetworkError: A network error occurred.\n \n Step 3: Cross origin request, allowed""}<_**next**_>{""sha"": ""c36c35a92c4399a626023ec7fbe7854eecd5cb99"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-unsafe-redirect-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-unsafe-redirect-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-unsafe-redirect-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/xmlhttprequest/xmlhttprequest-unsafe-redirect-expected.txt?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -2,8 +2,6 @@ CONSOLE MESSAGE: XMLHttpRequest cannot load http://localhost:8080/xmlhttprequest\n This tests that unsafe redirects won't be allowed when making an XMLHttpRequest.\n Sync XHR started.\n readyState change 1\n-readyState change 4\n-Error event.\n Exception: NetworkError: A network error occurred.\n Async XHR started.\n readyState change 1""}<_**next**_>{""sha"": ""8d93c13520d02e22bf5ba14280d93ec04a4505cf"", ""filename"": ""third_party/WebKit/Source/core/xml/XMLHttpRequest.cpp"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 34, ""changes"": 73, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/Source/core/xml/XMLHttpRequest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/Source/core/xml/XMLHttpRequest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/xml/XMLHttpRequest.cpp?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -889,36 +889,53 @@ void XMLHttpRequest::clearRequest()\n     m_requestEntityBody = 0;\n }\n \n-void XMLHttpRequest::genericError()\n+void XMLHttpRequest::handleDidFailGeneric()\n {\n     clearResponse();\n     clearRequest();\n-    m_error = true;\n \n-    changeState(DONE);\n+    m_error = true;\n }\n \n-void XMLHttpRequest::networkError()\n+void XMLHttpRequest::dispatchEventAndLoadEnd(const AtomicString& type)\n {\n-    genericError();\n     if (!m_uploadComplete) {\n         m_uploadComplete = true;\n         if (m_upload && m_uploadEventsAllowed)\n-            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().errorEvent));\n+            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(type));\n+    }\n+    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(type));\n+}\n+\n+void XMLHttpRequest::handleNetworkError()\n+{\n+    m_exceptionCode = NetworkError;\n+\n+    handleDidFailGeneric();\n+\n+    if (m_async) {\n+        changeState(DONE);\n+        dispatchEventAndLoadEnd(eventNames().errorEvent);\n+    } else {\n+        m_state = DONE;\n     }\n-    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().errorEvent));\n+\n     internalAbort();\n }\n \n-void XMLHttpRequest::abortError()\n+void XMLHttpRequest::handleDidCancel()\n {\n-    genericError();\n-    if (!m_uploadComplete) {\n-        m_uploadComplete = true;\n-        if (m_upload && m_uploadEventsAllowed)\n-            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().abortEvent));\n+    m_exceptionCode = AbortError;\n+\n+    handleDidFailGeneric();\n+\n+    if (!m_async) {\n+        m_state = DONE;\n+        return;\n     }\n-    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().abortEvent));\n+    changeState(DONE);\n+\n+    dispatchEventAndLoadEnd(eventNames().abortEvent);\n }\n \n void XMLHttpRequest::dropProtectionSoon()\n@@ -1086,33 +1103,30 @@ String XMLHttpRequest::statusText(ExceptionState& es) const\n \n void XMLHttpRequest::didFail(const ResourceError& error)\n {\n-\n     // If we are already in an error state, for instance we called abort(), bail out early.\n     if (m_error)\n         return;\n \n     if (error.isCancellation()) {\n-        m_exceptionCode = AbortError;\n-        abortError();\n+        handleDidCancel();\n         return;\n     }\n \n     if (error.isTimeout()) {\n-        didTimeout();\n+        handleDidTimeout();\n         return;\n     }\n \n     // Network failures are already reported to Web Inspector by ResourceLoader.\n     if (error.domain() == errorDomainWebKitInternal)\n         logConsoleError(scriptExecutionContext(), \""XMLHttpRequest cannot load \"" + error.failingURL() + \"". \"" + error.localizedDescription());\n \n-    m_exceptionCode = NetworkError;\n-    networkError();\n+    handleNetworkError();\n }\n \n void XMLHttpRequest::didFailRedirectCheck()\n {\n-    networkError();\n+    handleNetworkError();\n }\n \n void XMLHttpRequest::didFinishLoading(unsigned long identifier, double)\n@@ -1236,32 +1250,23 @@ void XMLHttpRequest::didReceiveData(const char* data, int len)\n     }\n }\n \n-void XMLHttpRequest::didTimeout()\n+void XMLHttpRequest::handleDidTimeout()\n {\n     // internalAbort() calls dropProtection(), which may release the last reference.\n     RefPtr<XMLHttpRequest> protect(this);\n     internalAbort();\n \n-    clearResponse();\n-    clearRequest();\n-\n-    m_error = true;\n     m_exceptionCode = TimeoutError;\n \n+    handleDidFailGeneric();\n+\n     if (!m_async) {\n         m_state = DONE;\n-        m_exceptionCode = TimeoutError;\n         return;\n     }\n-\n     changeState(DONE);\n \n-    if (!m_uploadComplete) {\n-        m_uploadComplete = true;\n-        if (m_upload && m_uploadEventsAllowed)\n-            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().timeoutEvent));\n-    }\n-    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().timeoutEvent));\n+    dispatchEventAndLoadEnd(eventNames().timeoutEvent);\n }\n \n bool XMLHttpRequest::canSuspend() const""}<_**next**_>{""sha"": ""eaacfb0964122e52d1807a045315a05dc9340291"", ""filename"": ""third_party/WebKit/Source/core/xml/XMLHttpRequest.h"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 4, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/Source/core/xml/XMLHttpRequest.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/aa1a102f73565feeb1d121d0d6c9524bebcdd75f/third_party/WebKit/Source/core/xml/XMLHttpRequest.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/xml/XMLHttpRequest.h?ref=aa1a102f73565feeb1d121d0d6c9524bebcdd75f"", ""patch"": ""@@ -83,7 +83,6 @@ class XMLHttpRequest : public ScriptWrappable, public RefCounted<XMLHttpRequest>\n     };\n \n     virtual void contextDestroyed();\n-    virtual void didTimeout();\n     virtual bool canSuspend() const;\n     virtual void suspend(ReasonForSuspension);\n     virtual void resume();\n@@ -173,6 +172,8 @@ class XMLHttpRequest : public ScriptWrappable, public RefCounted<XMLHttpRequest>\n     String getRequestHeader(const AtomicString& name) const;\n     void setRequestHeaderInternal(const AtomicString& name, const String& value);\n \n+    // Changes m_state and dispatches a readyStateChange event if new m_state\n+    // value is different from last one.\n     void changeState(State newState);\n     void callReadyStateChangeListener();\n     void dropProtectionSoon();\n@@ -184,9 +185,17 @@ class XMLHttpRequest : public ScriptWrappable, public RefCounted<XMLHttpRequest>\n \n     void createRequest(ExceptionState&);\n \n-    void genericError();\n-    void networkError();\n-    void abortError();\n+    // Dispatches an event of the specified type to m_upload and\n+    // m_progressEventThrottle.\n+    void dispatchEventAndLoadEnd(const AtomicString&);\n+    // Does clean up common for all kind of didFail() call.\n+    void handleDidFailGeneric();\n+    // Handles didFail() call not caused by cancellation or timeout.\n+    void handleNetworkError();\n+    // Handles didFail() call triggered by m_loader->cancel().\n+    void handleDidCancel();\n+    // Handles didFail() call for timeout.\n+    void handleDidTimeout();\n \n     OwnPtr<XMLHttpRequestUpload> m_upload;\n \n@@ -228,6 +237,9 @@ class XMLHttpRequest : public ScriptWrappable, public RefCounted<XMLHttpRequest>\n \n     unsigned m_lastSendLineNumber;\n     String m_lastSendURL;\n+    // An exception to throw in synchronous mode. It's set when failure\n+    // notification is received from m_loader and thrown at the end of send() if\n+    // any.\n     ExceptionCode m_exceptionCode;\n \n     XMLHttpRequestProgressEventThrottle m_progressEventThrottle;""}","const AtomicString& XMLHttpRequest::interfaceName() const
{
    return eventNames().interfaceForXMLHttpRequest;
}
","const AtomicString& XMLHttpRequest::interfaceName() const
{
    return eventNames().interfaceForXMLHttpRequest;
}
",C,,,,"@@ -889,36 +889,53 @@ void XMLHttpRequest::clearRequest()
     m_requestEntityBody = 0;
 }
 
-void XMLHttpRequest::genericError()
+void XMLHttpRequest::handleDidFailGeneric()
 {
     clearResponse();
     clearRequest();
-    m_error = true;
 
-    changeState(DONE);
+    m_error = true;
 }
 
-void XMLHttpRequest::networkError()
+void XMLHttpRequest::dispatchEventAndLoadEnd(const AtomicString& type)
 {
-    genericError();
     if (!m_uploadComplete) {
         m_uploadComplete = true;
         if (m_upload && m_uploadEventsAllowed)
-            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().errorEvent));
+            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(type));
+    }
+    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(type));
+}
+
+void XMLHttpRequest::handleNetworkError()
+{
+    m_exceptionCode = NetworkError;
+
+    handleDidFailGeneric();
+
+    if (m_async) {
+        changeState(DONE);
+        dispatchEventAndLoadEnd(eventNames().errorEvent);
+    } else {
+        m_state = DONE;
     }
-    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().errorEvent));
+
     internalAbort();
 }
 
-void XMLHttpRequest::abortError()
+void XMLHttpRequest::handleDidCancel()
 {
-    genericError();
-    if (!m_uploadComplete) {
-        m_uploadComplete = true;
-        if (m_upload && m_uploadEventsAllowed)
-            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().abortEvent));
+    m_exceptionCode = AbortError;
+
+    handleDidFailGeneric();
+
+    if (!m_async) {
+        m_state = DONE;
+        return;
     }
-    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().abortEvent));
+    changeState(DONE);
+
+    dispatchEventAndLoadEnd(eventNames().abortEvent);
 }
 
 void XMLHttpRequest::dropProtectionSoon()
@@ -1086,33 +1103,30 @@ String XMLHttpRequest::statusText(ExceptionState& es) const
 
 void XMLHttpRequest::didFail(const ResourceError& error)
 {
-
     // If we are already in an error state, for instance we called abort(), bail out early.
     if (m_error)
         return;
 
     if (error.isCancellation()) {
-        m_exceptionCode = AbortError;
-        abortError();
+        handleDidCancel();
         return;
     }
 
     if (error.isTimeout()) {
-        didTimeout();
+        handleDidTimeout();
         return;
     }
 
     // Network failures are already reported to Web Inspector by ResourceLoader.
     if (error.domain() == errorDomainWebKitInternal)
         logConsoleError(scriptExecutionContext(), ""XMLHttpRequest cannot load "" + error.failingURL() + "". "" + error.localizedDescription());
 
-    m_exceptionCode = NetworkError;
-    networkError();
+    handleNetworkError();
 }
 
 void XMLHttpRequest::didFailRedirectCheck()
 {
-    networkError();
+    handleNetworkError();
 }
 
 void XMLHttpRequest::didFinishLoading(unsigned long identifier, double)
@@ -1236,32 +1250,23 @@ void XMLHttpRequest::didReceiveData(const char* data, int len)
     }
 }
 
-void XMLHttpRequest::didTimeout()
+void XMLHttpRequest::handleDidTimeout()
 {
     // internalAbort() calls dropProtection(), which may release the last reference.
     RefPtr<XMLHttpRequest> protect(this);
     internalAbort();
 
-    clearResponse();
-    clearRequest();
-
-    m_error = true;
     m_exceptionCode = TimeoutError;
 
+    handleDidFailGeneric();
+
     if (!m_async) {
         m_state = DONE;
-        m_exceptionCode = TimeoutError;
         return;
     }
-
     changeState(DONE);
 
-    if (!m_uploadComplete) {
-        m_uploadComplete = true;
-        if (m_upload && m_uploadEventsAllowed)
-            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().timeoutEvent));
-    }
-    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().timeoutEvent));
+    dispatchEventAndLoadEnd(eventNames().timeoutEvent);
 }
 
 bool XMLHttpRequest::canSuspend() const",Chrome,aa1a102f73565feeb1d121d0d6c9524bebcdd75f,990d69a34631a05d2e0a4d49493179804a4b7c18,"const AtomicString& XMLHttpRequest::interfaceName() const
{
    return eventNames().interfaceForXMLHttpRequest;
}
",,,False
,buffer overflow 2,"int main(int argc, char **argv) { volatile int important_data = 0; char user_input[10]; gets(user_input); if(important_data != 0) { printf(""Warning !!!, the 'important_data' was changed\n""); } else { printf(""the 'important_data' was not changed\n""); } }",1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,False
,int overflow,"nresp = packet_get_int();
if (nresp > 0) {
response = xmalloc(nresp*sizeof(char*));
for (i = 0; i < nresp; i++) 
    response[i] = packet_get_string(NULL);
}",1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,True
,pointer init,"void main(){
int *ptr;
if (nullptr != ptr)
 {
*ptr = 5;
 }
}",1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,True
,type conversion,"#include <iostream>
#include <string>
using namespace std;
  
int main()
{
    string str;
    cout << ""Please enter your string: \n"";
    getline(cin, str);
    unsigned int len = str.length();
    if (len > -1)
    {
    cout << ""string length is "" << len << ""which is bigger than -1 "" <<std::endl;
    }else 
    {
    cout << ""string length is "" << len << "" which is less than -1 "" <<std::endl;
    }
    return 0;
}",1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,False
